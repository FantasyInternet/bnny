include "./leb128.wast"

~ BnNY ~ A WebAssembly assembler written in Poetry

var error
var src
var pos
var line
var column
var sections
var wasm

func reset
  rewind
  error = null
  sections =
    :type = array
    :import = array
    :function = array
    :table = array
    :memory = array
    :name = object

func rewind
  pos = 0
  line = 1
  column = 0

func assemble wast
  reset
  src = wast
  var token = read_token
  if token != "("
    return unexpected token "'('"
  token = read_token
  if token != "module"
    return unexpected token "'module'"
  read_module
  ~ error = json_encode sections
  if error
    return null
  else
    write_module
    return wasm

func croak message
  error = error || message + " at line " + line + ", column " + column + "!"

func unexpected actual expected
  var message = "unexpected token '" + actual + "'"
  if expected
    message += ", where " + expected + " should be"
  croak message

func is_eof
  return pos >= (size_of src)

func peek_char
  return ""+binary_slice src pos 1

func read_char
  var char = peek_char
  pos++
  column++
  if char == "\n"
    line++
    column = 0
  return char

func backstep
  pos--
  column--
  var char = peek_char
  if char == "\n"
    line--
    column = 0xfffffff
  return char

func read_raw_token
  var token
  var char = peek_char
  ~ skip whitespace
  while (char_code char) <= 0x20 && false == is_eof
    read_char
    char = peek_char
  if char == "("
    token = read_char
    char = peek_char
    if char == ";"
      token = char
      while (binary_search token ";)") == null && (false == is_eof)
        char = read_char
        binary_write token (size_of token) char
  elsif char == ")"
    token = read_char
  elsif char == "\""
    token = read_char
    char = read_char
    while char != "\"" && (false == is_eof)
      binary_write token (size_of token) char
      if char == "\\"
        char = read_char
        binary_write token (size_of token) char
      char = read_char
    ~ binary_write token (size_of token) char
  elsif char == ";"
    token = read_char
    char = peek_char
    if char == ";"
      while char != "\n" && (false == is_eof)
        char = read_char
        binary_write token (size_of token) char
  else
    token = ""+binary
    var illegals = "();\""
    while (char_code char) > 0x20 && (false == is_eof) && (binary_search illegals char) == null
      binary_write token (size_of token) char
      pos++
      char = peek_char
  return token

func read_token
  var token = ";;"
  while (binary_search token ";;") == 0
    token = read_raw_token
  if token == ")"
    backstep
    token = null
  return token

func exit_parens
  var token = ";;"
  while token && token != ")"
    token = read_raw_token
    if token == "("
      exit_parens
  return token

func is_name token
  return (binary_search token "$") == 0
func is_string token
  return (binary_search token "\"") == 0
func is_number token
  var digits = "0123456789"
  var char = binary_slice token 0 1
  return (binary_search digits char) != null


~~~ read wast ~~~

func read_module
  var token = read_token
  while token
    if token == "("
      token = read_token
      if token == "import"
        read_import
      elsif token == "table"
        read_table_type true
      elsif token == "memory"
        read_memory_type true
      elsif token == "func"
        read_func_type true
      else
        ~ return unexpected token "module-level token"
        exit_parens
    else
      return unexpected token "'('"
    token = read_token
  exit_parens

func read_import
  var _import = object
  var token = read_token
  while token
    if (is_string token)
      _import:module = ""+binary_slice token 1 (size_of token)
      token = read_token
      if (is_string token)
        _import:field = ""+binary_slice token 1 (size_of token)
      else
        return unexpected token "a string"
    elsif token == "("
      token = read_token
      if token == "func"
        _import:kind = 0
        _import:type = read_func_type
      elsif token == "table"
        _import:kind = 1
        _import:type = read_table_type
      elsif token == "memory"
        _import:kind = 2
        _import:type = read_memory_type
      elsif token == "global"
        _import:kind = 3
        _import:type = read_global_type
      else
        return unexpected token "a valid import"
    else
      return unexpected token
    token = read_token
  exit_parens
  array_push sections:import _import
  return _import

func read_table_type save
  var type = object
  var token = read_token
  while token
    if is_number token
      if type:initial == null
        type:initial = json_decode token
      else
        type:maximum = json_decode token
    elsif is_name token
      ;
    elsif token == "i32"
      type:element_type = 0x7f
    elsif token == "i64"
      type:element_type = 0x7e
    elsif token == "f32"
      type:element_type = 0x7d
    elsif token == "f64"
      type:element_type = 0x7c
    elsif token == "anyfunc"
      type:element_type = 0x70
    elsif token == "func"
      type:element_type = 0x60
    else
      return unexpected token
    token = read_token
  exit_parens
  if save
    array_push sections:table type
  return type

func read_memory_type save
  var type = object
  var token = read_token
  while token
    if is_number token
      if type:initial == null
        type:initial = json_decode token
      elsif type:maximum == null
        type:maximum = json_decode token
      else
        return unexpected token
    elsif is_name token
      ;
    else
      return unexpected token
    token = read_token
  exit_parens
  if save
    array_push sections:memory type
  return type

func read_global_type
  var type = object
  var token = read_token
  while token
    if token == "("
      type += read_global_type
    elsif is_name token
      ;
    elsif token == "mut"
      type:mutability = 1
    elsif token == "i32"
      type:content_type = 0x7f
    elsif token == "i64"
      type:content_type = 0x7e
    elsif token == "f32"
      type:content_type = 0x7d
    elsif token == "f64"
      type:content_type = 0x7c
    else
      return unexpected token
    token = read_token
  exit_parens
  return type

func read_func_type save
  var type =
    :form = 0x60
    :params = array
    :returns = array

  var token = read_token
  while token
    if token == "("
      token = read_token
      if token == "param"
        while token
          if token == "i32"
            array_push type:params 0x7f
          elsif token == "i64"
            array_push type:params 0x7e
          elsif token == "f32"
            array_push type:params 0x7d
          elsif token == "f64"
            array_push type:params 0x7c
          token = read_token
        exit_parens
      elsif token == "result"
        while token
          if token == "i32"
            array_push type:returns 0x7f
          elsif token == "i64"
            array_push type:returns 0x7e
          elsif token == "f32"
            array_push type:returns 0x7d
          elsif token == "f64"
            array_push type:returns 0x7c
          token = read_token
        exit_parens
      else
        exit_parens
    token = read_token
  exit_parens

  type = json_encode type
  var type_index = array_search sections:type type
  if type_index == null
    type_index = array_length sections:type
    array_push sections:type type
  if save
    array_push sections:function type_index
  return type


~~~ write wasm ~~~

func write_module
  wasm = binary_string 8
  binary_write wasm 1 "asm"
  binary_write wasm 4 1
  write_type_section
  write_import_section
  write_function_section
  write_table_section
  write_memory_section

func write_string bin str
  write_varuint bin size_of str
  binary_write bin (size_of bin) str

func write_resizable_limits bin limits
  if limits:maximum == null
    write_varuint bin 0
    write_varuint bin limits:initial
  else
    write_varuint bin 1
    write_varuint bin limits:initial
    write_varuint bin limits:maximum


func write_type_section
  if (array_length sections:type) == 0
    return null
  var bin = binary
  write_varuint bin (array_length sections:type)
  for type in sections:type
    type = json_decode type
    write_varuint bin type:form
    write_varuint bin (array_length type:params)
    for param in type:params
      write_varuint bin param
    write_varuint bin (array_length type:returns)
    for _return in type:returns
      write_varuint bin _return

  write_varuint wasm 0x1
  write_varuint wasm (size_of bin)
  binary_write wasm (size_of wasm) bin

func write_import_section
  if (array_length sections:import) == 0
    return null
  var bin = binary
  write_varuint bin (array_length sections:import)
  for _import in sections:import
    write_string bin _import:module
    write_string bin _import:field
    write_varuint bin _import:kind
    if _import:kind == 0 ~ function
      write_varuint bin (array_search sections:type _import:type)
    if _import:kind == 1 ~ table
      write_varuint bin _import:type:element_type
      write_resizable_limits bin _import:type
    if _import:kind == 2 ~ memory
      write_resizable_limits bin _import:type
    if _import:kind == 3 ~ global
      write_varuint bin _import:type:content_type
      write_varuint bin _import:type:mutability

  write_varuint wasm 0x2
  write_varuint wasm (size_of bin)
  binary_write wasm (size_of wasm) bin

func write_function_section
  if (array_length sections:function) == 0
    return null
  var bin = binary
  write_varuint bin (array_length sections:function)
  for function in sections:function
    write_varuint bin function

  write_varuint wasm 0x3
  write_varuint wasm (size_of bin)
  binary_write wasm (size_of wasm) bin

func write_table_section
  if (array_length sections:table) == 0
    return null
  var bin = binary
  write_varuint bin (array_length sections:table)
  for table in sections:table
    write_varuint bin table:element_type
    write_resizable_limits bin table

  write_varuint wasm 0x4
  write_varuint wasm (size_of bin)
  binary_write wasm (size_of wasm) bin

func write_memory_section
  if (array_length sections:memory) == 0
    return null
  var bin = binary
  write_varuint bin (array_length sections:memory)
  for memory in sections:memory
    write_resizable_limits bin memory

  write_varuint wasm 0x5
  write_varuint wasm (size_of bin)
  binary_write wasm (size_of wasm) bin
