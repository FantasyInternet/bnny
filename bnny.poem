include "./leb128.wast"

~ BnNY ~ A WebAssembly assembler written in Poetry

var error
var src
var pos
var line
var column
var sections
var wasm

func reset
  rewind
  error = null
  sections =
    :type = array
    :name = object
  wasm = binary_string 8
  binary_write wasm 1 "asm"
  binary_write wasm 4 1

func rewind
  pos = 0
  line = 0
  column = 0

func assemble wast
  reset
  src = wast
  var token = read_token
  if token != "("
    return unexpected "(" token
  token = read_token
  if token != "module"
    return unexpected "module" token
  read_module
  if error
    return null
  else
    write_module
    return wasm

func croak message
  error = error || message + " at line " + line + ", column " + column + "!"

func unexpected expected actual
  croak "expected " + expected + ", not '" + actual + "'"

func is_eof
  return pos >= (size_of src)

func peek_char
  return ""+binary_slice src pos 1

func read_char
  var char = peek_char
  pos++
  column++
  if char == "\n"
    line++
    column = 0
  return char

func backstep
  pos--
  column--
  var char = peek_char
  if char == "\n"
    line--
    column = 0xfffffff
  return char

func read_raw_token
  var token
  var char = peek_char
  ~ skip whitespace
  while (char_code char) <= 0x20 && false == is_eof
    read_char
    char = peek_char
  if char == "("
    token = read_char
    char = peek_char
    if char == ";"
      token = char
      while (binary_search token ";)") == null && (false == is_eof)
        char = read_char
        binary_write token (size_of token) char
  elsif char == ")"
    token = read_char
  elsif char == "\""
    token = read_char
    char = read_char
    while char != "\"" && (false == is_eof)
      binary_write token (size_of token) char
      if char == "\\"
        char = read_char
        binary_write token (size_of token) char
      char = read_char
    binary_write token (size_of token) char
  elsif char == ";"
    token = read_char
    char = peek_char
    if char == ";"
      while char != "\n" && (false == is_eof)
        char = read_char
        binary_write token (size_of token) char
  else
    token = ""+binary
    var illegals = "();\""
    while (char_code char) > 0x20 && (false == is_eof) && (binary_search illegals char) == null
      binary_write token (size_of token) char
      pos++
      char = peek_char
  return token

func read_token
  var token = ";;"
  while (binary_search token ";;") == 0
    token = read_raw_token
  if token == ")"
    backstep
    token = null
  return token

func exit_parens
  var token = ";;"
  while token && token != ")"
    token = read_raw_token
    if token == "("
      exit_parens
  return token

~~~ read wast ~~~

func read_module
  var token = read_token
  while token
    if token == "("
      token = read_token
      if token == "import"
        read_import
      elsif token == "func"
        read_func_type
      else
        ~ return unexpected "module-level token" token
        exit_parens
    else
      return unexpected "(" token
    token = read_token
  exit_parens

func read_import
  var token = read_token
  while token
    if token == "("
      token = read_token
      if token == "func"
        read_func_type
      else
        exit_parens
    token = read_token
  exit_parens

func read_func_type
  var type =
    :form = 0x60
    :params = array
    :returns = array

  var token = read_token
  while token
    if token == "("
      token = read_token
      if token == "param"
        while token
          if token == "i32"
            array_push type:params 0x7f
          elsif token == "i64"
            array_push type:params 0x7e
          elsif token == "f32"
            array_push type:params 0x7d
          elsif token == "f64"
            array_push type:params 0x7c
          token = read_token
        exit_parens
      elsif token == "result"
        while token
          if token == "i32"
            array_push type:returns 0x7f
          elsif token == "i64"
            array_push type:returns 0x7e
          elsif token == "f32"
            array_push type:returns 0x7d
          elsif token == "f64"
            array_push type:returns 0x7c
          token = read_token
        exit_parens
      else
        exit_parens
    token = read_token
  exit_parens

  type = json_encode type
  if (array_search sections:type type) == null
    array_push sections:type type

~~~ write wasm ~~~

func write_module
  write_type_section

func write_type_section
  var bin = binary
  write_varuint bin (array_length sections:type)
  for type in sections:type
    var _type = json_decode type
    write_varuint bin _type:form
    write_varuint bin (array_length _type:params)
    for param in _type:params
      write_varuint bin param
    write_varuint bin (array_length _type:returns)
    for _return in _type:returns
      write_varuint bin _return

  write_varuint wasm 0x1
  write_varuint wasm (size_of bin)
  binary_write wasm (size_of wasm) bin

func write_func_type bin type
  ;
